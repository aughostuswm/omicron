/*!
 * API simulation of an Oxide rack, used for testing and prototyping.
 */

use async_trait::async_trait;
use chrono::Utc;
use futures::lock::Mutex;
use futures::stream::StreamExt;
use std::collections::BTreeMap;
use std::convert::TryFrom;
use std::sync::Arc;
use uuid::Uuid;

use crate::api_error::ApiError;
use crate::api_model::ApiBackend;
use crate::api_model::ApiIdentityMetadata;
use crate::api_model::ApiInstance;
use crate::api_model::ApiInstanceCreateParams;
use crate::api_model::ApiInstanceState;
use crate::api_model::ApiName;
use crate::api_model::ApiProject;
use crate::api_model::ApiProjectCreateParams;
use crate::api_model::ApiProjectUpdateParams;
use crate::api_model::ApiResourceType;
use crate::api_model::CreateResult;
use crate::api_model::DeleteResult;
use crate::api_model::ListResult;
use crate::api_model::LookupResult;
use crate::api_model::PaginationParams;
use crate::api_model::UpdateResult;
use crate::api_model::DEFAULT_LIST_PAGE_SIZE;

/**
 * SimulatorBuilder is used to initialize and populate a Simulator
 * synchronously, before we've wrapped the guts in a Mutex that can only be
 * locked in an async context.
 */
pub struct SimulatorBuilder {
    projects: Vec<SimBuilderProject>,
}

struct SimBuilderProject {
    id: String,
    name: String,
}

impl SimulatorBuilder {
    pub fn new() -> Self {
        SimulatorBuilder {
            projects: Vec::new(),
        }
    }

    /**
     * Seed the simulator with a generic-looking project called "project_name".
     */
    pub fn project_create(&mut self, project_id: &str, project_name: &str) {
        self.projects.push(SimBuilderProject {
            id: project_id.to_string(),
            name: project_name.to_string(),
        });
    }

    /**
     * Return a Simulator instance holding the state created using this builder.
     */
    pub fn build(self) -> Simulator {
        let mut projects_by_name: BTreeMap<ApiName, Arc<ApiProject>> =
            BTreeMap::new();
        let now = Utc::now();

        for builder_project in self.projects {
            let simproject = SimProject {
                instances: Mutex::new(BTreeMap::new()),
            };
            let id_validated = Uuid::parse_str(&builder_project.id)
                .expect("unsupported project id");
            let name_validated =
                ApiName::try_from(builder_project.name.clone())
                    .expect("unsupported project name");
            projects_by_name.insert(
                name_validated.clone(),
                Arc::new(ApiProject {
                    backend_impl: Box::new(simproject),
                    identity: ApiIdentityMetadata {
                        id: id_validated,
                        name: name_validated,
                        description: "<auto-generated at server startup>"
                            .to_string(),
                        time_created: now.clone(),
                        time_modified: now.clone(),
                    },
                    generation: 1,
                }),
            );
        }

        Simulator {
            projects_by_name: Arc::new(Mutex::new(projects_by_name)),
        }
    }
}

/**
 * Maintains simulated state of the Oxide rack.  The current implementation is
 * in-memory only.
 */
pub struct Simulator {
    /** all projects, indexed by name. */
    projects_by_name: Arc<Mutex<BTreeMap<ApiName, Arc<ApiProject>>>>,
}

/**
 * Backend-specific implementation of an ApiProject.
 */
struct SimProject {
    instances: Mutex<BTreeMap<ApiName, Arc<ApiInstance>>>,
}
fn sim_project(api_project: &ApiProject) -> &SimProject {
    api_project.backend_impl.as_ref().downcast_ref::<SimProject>().unwrap()
}

/**
 * Backend-specific implementation of an ApiInstance.  We currently don't need
 * any additional fields for this.
 */
#[derive(Clone)]
struct SimInstance {}

#[async_trait]
impl ApiBackend for Simulator {
    async fn project_create(
        &self,
        new_project: &ApiProjectCreateParams,
    ) -> CreateResult<ApiProject> {
        let mut projects_by_name = self.projects_by_name.lock().await;
        if projects_by_name.contains_key(&new_project.identity.name) {
            return Err(ApiError::ObjectAlreadyExists {
                type_name: ApiResourceType::Project,
                object_name: String::from(new_project.identity.name.clone()),
            });
        }

        let now = Utc::now();
        let newname = &new_project.identity.name;
        let simproject = SimProject {
            instances: Mutex::new(BTreeMap::new()),
        };
        let project = Arc::new(ApiProject {
            backend_impl: Box::new(simproject),
            identity: ApiIdentityMetadata {
                id: Uuid::new_v4(),
                name: newname.clone(),
                description: new_project.identity.description.clone(),
                time_created: now.clone(),
                time_modified: now.clone(),
            },
            generation: 1,
        });

        let rv = Arc::clone(&project);
        projects_by_name.insert(newname.clone(), project);
        Ok(rv)
    }

    async fn projects_list(
        &self,
        pagparams: &PaginationParams<ApiName>,
    ) -> ListResult<ApiProject> {
        let projects_by_name = self.projects_by_name.lock().await;
        collection_list(&projects_by_name, pagparams).await
    }

    async fn project_lookup(&self, name: &ApiName) -> LookupResult<ApiProject> {
        let mut projects = self.projects_by_name.lock().await;
        let project =
            collection_lookup(&mut projects, name, ApiResourceType::Project)?;
        let rv = Arc::clone(project);
        Ok(rv)
    }

    async fn project_delete(&self, name: &ApiName) -> DeleteResult {
        let mut projects = self.projects_by_name.lock().await;
        projects.remove(name).ok_or_else(|| ApiError::ObjectNotFound {
            type_name: ApiResourceType::Project,
            object_name: String::from(name.clone()),
        })?;
        Ok(())
    }

    async fn project_update(
        &self,
        name: &ApiName,
        new_params: &ApiProjectUpdateParams,
    ) -> UpdateResult<ApiProject> {
        let now = Utc::now();
        let mut projects = self.projects_by_name.lock().await;

        let oldproject: Arc<ApiProject> =
            projects.remove(name).ok_or_else(|| ApiError::ObjectNotFound {
                type_name: ApiResourceType::Project,
                object_name: String::from(name.clone()),
            })?;
        let oldbe = sim_project(&oldproject);
        let newname = &new_params
            .identity
            .name
            .as_ref()
            .unwrap_or(&oldproject.identity.name);
        let newdescription = &new_params
            .identity
            .description
            .as_ref()
            .unwrap_or(&oldproject.identity.description);
        let newgen = oldproject.generation + 1;

        /*
         * Right now, it's fine to just create a new backend object as we do
         * here.  It's not clear if that will work once we flesh out this
         * implementation (e.g., if there's other state in that object).
         * However, there could be other holders of the Arc<ApiProject> right
         * now, so we can't just move "backend_impl" into the new object.  We'd
         * have to either mutate the original ApiProject, construct a whole new
         * SimProject (which is what we do here because it's trivial), or else
         * put the SimProject behind an Arc.  (It's not clear that will make
         * sense -- the two ApiProjects will have different state!)
         */
        let old_instances = oldbe.instances.lock().await;
        let beimpl: Box<SimProject> = Box::new(SimProject {
            instances: Mutex::new(old_instances.clone()),
        });
        let newvalue = Arc::new(ApiProject {
            backend_impl: beimpl,
            identity: ApiIdentityMetadata {
                id: oldproject.identity.id.clone(),
                name: (*newname).clone(),
                description: (*newdescription).clone(),
                time_created: oldproject.identity.time_created.clone(),
                time_modified: now.clone(),
            },
            generation: newgen,
        });

        let rv = Arc::clone(&newvalue);
        projects.insert(newvalue.identity.name.clone(), newvalue);
        Ok(rv)
    }

    /*
     * Instances
     */

    async fn project_list_instances(
        &self,
        project_name: &ApiName,
        pagparams: &PaginationParams<ApiName>,
    ) -> ListResult<ApiInstance> {
        let project = self.project_lookup(project_name).await?;
        let simproject = sim_project(&project);
        let instances = simproject.instances.lock().await;
        collection_list(&instances, pagparams).await
    }

    async fn project_create_instance(
        &self,
        project_name: &ApiName,
        params: &ApiInstanceCreateParams,
    ) -> CreateResult<ApiInstance> {
        let now = Utc::now();
        let newname = params.identity.name.clone();

        let mut projects = self.projects_by_name.lock().await;
        let project = collection_lookup(
            &mut projects,
            project_name,
            ApiResourceType::Project,
        )?;
        let simproject = sim_project(project);
        let mut instances = simproject.instances.lock().await;
        if instances.contains_key(&newname) {
            return Err(ApiError::ObjectAlreadyExists {
                type_name: ApiResourceType::Instance,
                object_name: String::from(newname),
            });
        }

        let instance = Arc::new(ApiInstance {
            backend_impl: Box::new(SimInstance {}),
            identity: ApiIdentityMetadata {
                id: Uuid::new_v4(),
                name: params.identity.name.clone(),
                description: params.identity.description.clone(),
                time_created: now.clone(),
                time_modified: now.clone(),
            },
            project_id: project.identity.id.clone(),
            ncpus: params.ncpus,
            memory: params.memory,
            boot_disk_size: params.boot_disk_size,
            hostname: params.hostname.clone(),
            /* TODO-debug: add state timestamp */
            state: ApiInstanceState::Starting,
        });

        let rv = Arc::clone(&instance);
        instances.insert(newname, instance);
        Ok(rv)
    }

    async fn project_lookup_instance(
        &self,
        project_name: &ApiName,
        instance_name: &ApiName,
    ) -> LookupResult<ApiInstance>
    {
        let mut projects = self.projects_by_name.lock().await;
        let project = collection_lookup(
            &mut projects,
            project_name,
            ApiResourceType::Project,
        )?;
        let simproject = sim_project(project);
        let instances = simproject.instances.lock().await;
        let instance = collection_lookup(
            &instances,
            instance_name,
            ApiResourceType::Instance,
        )?;
        Ok(Arc::clone(instance))
    }

    async fn project_delete_instance(
        &self,
        project_name: &ApiName,
        instance_name: &ApiName,
    ) -> DeleteResult
    {
        let mut projects = self.projects_by_name.lock().await;
        let project = collection_lookup(
            &mut projects,
            project_name,
            ApiResourceType::Project,
        )?;
        let simproject = sim_project(project);
        let mut instances = simproject.instances.lock().await;

        instances.remove(instance_name).ok_or_else(|| ApiError::ObjectNotFound {
            type_name: ApiResourceType::Instance,
            object_name: String::from(instance_name.clone()),
        })?;
        Ok(())
    }
}

/**
 * List a page of items from a collection.
 */
async fn collection_list<KeyType, ValueType>(
    tree: &BTreeMap<KeyType, Arc<ValueType>>,
    pagparams: &PaginationParams<KeyType>,
) -> ListResult<ValueType>
where
    KeyType: std::cmp::Ord,
    ValueType: Send + Sync + 'static,
{
    /* TODO-cleanup this logic should be in a wrapper function? */
    let limit = pagparams.limit.unwrap_or(DEFAULT_LIST_PAGE_SIZE);

    /*
     * We assemble the list of results that we're going to return now.  If the
     * caller is holding a lock, they'll be able to release it right away.  This
     * also makes the lifetime of the return value much easier.
     */
    let collect_items =
        |iter: &mut dyn Iterator<Item = (&KeyType, &Arc<ValueType>)>| {
            iter.take(limit)
                .map(|(_, arcitem)| Ok(Arc::clone(&arcitem)))
                .collect::<Vec<Result<Arc<ValueType>, ApiError>>>()
        };

    let items = match &pagparams.marker {
        None => collect_items(&mut tree.iter()),
        /*
         * NOTE: This range is inclusive on the low end because that
         * makes it easier for the client to know that it hasn't missed
         * some items in the namespace.  This does mean that clients
         * have to know to skip the first item on each page because
         * it'll be the same as the last item on the previous page.
         * TODO-cleanup would it be a problem to just make this an
         * exclusive bound?  It seems like you couldn't fail to see any
         * items that were present for the whole scan, which seems like
         * the main constraint.
         */
        Some(start_value) => collect_items(&mut tree.range(start_value..)),
    };

    Ok(futures::stream::iter(items).boxed())
}

/*
 * TODO-cleanup: for consistency and generality it would be nice if we could
 * make this take a KeyType type parameters, but I'm not sure how to specify the
 * bound that &KeyType: Into<String>
 */
fn collection_lookup<'a, 'b, ValueType>(
    tree: &'b BTreeMap<ApiName, Arc<ValueType>>,
    name: &'a ApiName,
    resource_type: ApiResourceType,
) -> Result<&'b Arc<ValueType>, ApiError> {
    Ok(tree.get(name).ok_or_else(|| ApiError::ObjectNotFound {
        type_name: resource_type,
        object_name: String::from(name.clone()),
    })?)
}
