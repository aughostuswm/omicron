/*!
 * API simulation of an Oxide rack, used for testing and prototyping.
 */

use async_trait::async_trait;
use futures::lock::Mutex;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::sync::Arc;

use crate::api_error::ApiError;
use crate::api_model::ApiBackend;
use crate::api_model::ApiObject;
use crate::api_model::ApiObjectCreateable;
use crate::api_model::ApiObjectUpdateable;
use crate::api_model::ApiProject;
use crate::api_model::ApiProjectCreateParams;
use crate::api_model::ApiProjectUpdateParams;
use crate::api_model::ApiProjectView;
use crate::api_model::CreateResult;
use crate::api_model::DeleteResult;
use crate::api_model::LookupResult;
use crate::api_model::UpdateResult;

/**
 * SimulatorBuilder is used to initialize and populate a Simulator
 * synchronously, before we've wrapped the guts in a Mutex that can only be
 * locked in an async context.
 */
pub struct SimulatorBuilder {
    projects_by_name: BTreeSet<String>
}

impl SimulatorBuilder {
    pub fn new() -> Self
    {
        SimulatorBuilder {
            projects_by_name: BTreeSet::new()
        }
    }

    pub fn project_create(&mut self, project_name: &str)
    {
        let name = project_name.to_string();
        self.projects_by_name.insert(name.clone(), name.clone());
    }

    pub fn build(self)
        -> Arc<Simulator>
    {
        let projects_by_name : BTreeMap<String, Arc<SimProject>> = 
            BTreeMap::new();

        let mut sim = Simulator {
            self_arc: None,
            projects_by_name: Arc::new(Mutex::new(projects_by_name))
        }

        sim.self_arc = Arc::new(sim);

        for projname in self.projects_by_name {
            projects_by_name.insert(projname.clone(), Arc::new(SimProject {
                backend: Arc::clone(&sim.self_arc),
                id: projname.clone(),
                name: projname.clone(),
                description: "<auto-generated at server startup>",
                generation: 1
            }));
        }
    }
}

/**
 * Maintains simulated state of the Oxide rack.  The current implementation is
 * in-memory only.
 */
pub struct Simulator {
    /*
     * TODO This feels like kind of a hack.  The problem is that in order for
     * people to be able to use SimProject (as a struct implementing the
     * ApiProject trait), SimProject needs a reference back to the simulator (so
     * that when you call delete(), for example, SimProject can reach into the
     * Simulator and remove itself.  In order to have multiple thread-safe
     * references to the Simulator, we use an Arc.  However, there's _also_ a
     * reference to the Simulator in the backend -- that's important for API
     * endpoints to be able to reach into the Simulator (as an ApiBackend) to do
     * things like create projects in the first place.  For that to work, it
     * also needs an Arc -- and it needs to be the same family of Arcs used in
     * the SimProjects (since you can't have two different Arcs each owning a
     * thing).  To make all this work, the ur Arc lives here, in the simulator
     * itself.  We clone that one when we want to return the Simulator in the
     * first place and when we want to stash a reference in a new SimProject
     * struct.
     *
     * Even worse, this has to be an Option because there's a circularity
     * problem in creating a Simuator with a reference to itself.
     * XXX
     */
    self_arc: Option<Arc<Simulator>>,

    projects_by_name: Arc<Mutex<BTreeMap<String, Arc<SimProject>>>>
}

#[async_trait]
impl ApiBackend for Simulator {
    async fn project_create(&self, new_project: &ApiProjectCreateParams)
        -> CreateResult<dyn ApiProject>
    {
        let mut projects_by_name = self.projects_by_name.lock().await;
        if projects_by_name.contains_key(&new_project.name) {
            // XXX better error
            return Err(ApiError {});
        }

        let newname = &new_project.name;
        let project = Arc::new(SimProject { 
            backend: Arc::clone(&self.self_arc.unwrap()),
            id: newname.clone(), // XXX
            name: newname.clone(),
            description: new_project.description.clone(),
            generation: 1
        });

        let rv = Arc::clone(&project);
        projects_by_name.insert(newname.clone(), project);
        Ok(rv)
    }

    async fn project_lookup(&self, name: String) ->
        LookupResult<dyn ApiProject>
    {
        let projects = self.projects_by_name.lock().await;
        // XXX better error
        let project = projects.get(&name)
            .ok_or_else(|| ApiError {})?;
        let rv = Arc::clone(project);
        Ok(rv)
    }
}

/**
 * Representation of a Project within the simulated Backend.  This is
 * potentially distinct from the representation in the API, since the API may
 * contain a stable set of fields, while the underlying representation could
 * change.
 */
struct SimProject {
    backend: Arc<Simulator>,

    id: String,
    name: String,
    description: String,
    generation: u64
}

impl ApiProject for SimProject {}

impl ApiObject for SimProject {
    type View = ApiProjectView;

    fn to_view(&self) 
        -> Self::View
    {
        ApiProjectView {
            id: self.id.clone(),
            name: self.name.clone(),
            description: self.description.clone()
        }
    }
}

#[async_trait]
impl ApiObjectCreateable for SimProject {
    type CreateParams = ApiProjectCreateParams;

    async fn delete(&self)
        -> DeleteResult
    {
        // XXX check generation?
        let sim = &self.backend;
        let mut projects = sim.projects_by_name.lock().await;
        let oldvalue = projects.remove(&self.name);
        if oldvalue.is_none() {
            // XXX better error
            return Err(ApiError {});
        }

        // XXX should compare generation in map with self.generation
        Ok(())
    }
}

#[async_trait]
impl ApiObjectUpdateable<ApiProjectView> for SimProject {
    type UpdateParams = ApiProjectUpdateParams;

    async fn update(&self, new_params: &ApiProjectUpdateParams)
        -> UpdateResult<dyn ApiObjectUpdateable<ApiProjectView, UpdateParams=Self::UpdateParams>>
    {
        let sim = &self.backend;
        let mut projects = sim.projects_by_name.lock().await;

        // XXX cleaner?
        let oldvalue : Arc<SimProject> = match projects.remove(&self.name) {
            // XXX better error
            None => return Err(ApiError {}),
            Some(v) => v
        };

        // XXX should compare generation in map with self.generation
        // XXX this could all use some cleanup
        let newname = &new_params.name.as_ref().unwrap_or(&oldvalue.name);
        let newdescription = &new_params.description.as_ref().unwrap_or(&oldvalue.description);
        let newvalue = Arc::new(SimProject {
            backend: Arc::clone(&oldvalue.backend),
            id: oldvalue.id.clone(),
            name: (*newname).clone(),
            description: (*newdescription).clone(),
            generation: oldvalue.generation + 1
        });

        let rv = Arc::clone(&newvalue);
        projects.insert(newvalue.name.clone(), newvalue);

        // TODO I'm not sure why I need this "as" expression here.
        Ok(rv as
            Arc<dyn ApiObjectUpdateable<ApiProjectView,
            UpdateParams=ApiProjectUpdateParams>>)
    }
}
