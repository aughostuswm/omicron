:showtitle:
:icons: font

= TODO

API endpoints:

* `/servers`?
* `/disks` and related endpoints
* RFD 24: regions, AZs, etc
* (lots more)

Work queue (see also: existing GitHub issues):

* use serde_json::StreamDeserializer where we use NDJSON
* document Dropshot
* write some design documents
* PUT should be idempotent and complete or else we should use PATCH
* make API fields consistent (camel case vs. snake case, use of timestamps)
* implement audit log
* implement alerts
* implement external user authentication
* implement external user authorization mechanism
* implement throttling and load shedding described in RFD 6
* implement hardening in RFD 10
* implement ETag / If-Match / If-None-Match
* implement limits for all types of resources
* polish pagination mechanisms (opaque token?  What does Stripe do?)
* integrate a real data storage backend
* implement scheme for API versioning
** how to identify the requested version -- header or URI?
** translators for older versions?
** integration of supported API versions into build artifact?
** Should all the uses of serde_json disallow unrecognized fields?  Should any?
* debugging/monitoring: Prometheus?
* debugging/monitoring: OpenTracing? OpenTelemetry?
* debugging/monitoring: Dynamic tracing?
* debugging/monitoring: Core files?
* settle on an approach for modification of resources and implement it once
* Automated testing
** General API testing: there's a lot of boilerplate in hand-generated tests
   for each kind of resource.  Would it be reasonable / possible to have a sort
   of omnibus test that's given the OpenAPI spec (or something like it),
   creates a hierarchy with at least one of every possible resource, and does
   things like: For each possible resource
*** attempt to (create, get, put, delete) one with an invalid name
*** attempt to (GET, DELETE, PUT) one that does not exist
*** attempt to create one with invalid JSON
*** attempt to create one with a duplicate name of the one we know about
*** exercise list operation with marker and limit (may need to create many of them)
*** for each required input property:
**** attempt to create a resource without that property
*** for each input property: attempt to create a resource with invalid values
    for that property
*** list instances of that resource and expect to find the one we know about
*** GET the one instance we know about
*** DELETE the one instance we know about
*** GET the one instance we know about again and expect it to fail
*** list instances again and expect to find nothing

External dependencies / open questions:

* Should we consider switching to sync?
* would like to require that servers have unique, immutable uuids
* TLS:
** How will we do TLS termination?
** How will we manage server certificates?
** How will we manage client certificates?
* what data storage backend will we use?
* flesh out several interfaces:
** OXCP -> server controller
** server controller -> OXCP (bootstrapping)
** server controller -> OXCP (alerts, faults, support bundles, state changes)
** internal -> OXCP: connected clients, recent requests, etc.
* what does bootstrapping / key management look like?
* what does internal authorization look like?

Other activities:

* Performance testing
* Stress testing
* Fault testing / under load
* Fuzz testing
* Security review
