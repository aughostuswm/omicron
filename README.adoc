:showtitle:
:toc: left
:icons: font

= Oxide API Prototype

This repo houses a prototype for the Oxide Rack API.  See:

* https://github.com/oxidecomputer/rfd/tree/master/rfd/0004[RFD 4 User Facing API Design]
* https://github.com/oxidecomputer/rfd/tree/master/rfd/0010[RFD 10 API Prototype and Simulated Implementation]

== Status

The code here is very rough at this point.

There are a couple of somewhat independent efforts, in no particular order:

* API server guts: work out the shape of the HTTP and API layers.  (See
  DESIGN.md.)
* OpenAPI integration.  See RFD 10 for notes on this.  Figure out the approach
  and implement it (e.g., decide that the server code is the source of truth,
  define some syntax for noting that in code, and then implement a tool to
  process this and produce an OpenAPI spec file).
* Rest of the server: logging, tracing, error handling, etc. that we want.

See <<_todo>> for more info.

== Build and run

The server requires a configuration file to run.  You can use
`examples/config.toml` to start with.  Build and run the server:

[source,text]
----
$ cargo run -- examples/config.toml
...
listening: http://127.0.0.1:12220
----

Use `curl` to hit the server:

[source,text]
----
$ curl -i http://127.0.0.1:12220/projects
HTTP/1.1 200 OK
content-type: application/x-ndjson
x-request-id: f5b58969-2df8-4bd9-8fef-8e42a6c02d69
content-length: 279
date: Mon, 16 Mar 2020 21:26:08 GMT

{"id":"simproject1","name":"simproject1","description":"<auto-generated at server startup>"}
{"id":"simproject2","name":"simproject2","description":"<auto-generated at server startup>"}
{"id":"simproject3","name":"simproject3","description":"<auto-generated at server startup>"}
----

You can run the tests with `cargo test`.  The test suite runs cleanly and should
remain clean.

== Configuration

The server requires a TOML configuration file.  There's an example in
`examples/config.toml`:

[source,toml]
----
include::examples/config.toml[]
----

Supported config properties include:

[cols="4",options="header"]
|===
|Name
|Example
|Required?
|Description

|`dropshot.bind_address`
|`"127.0.0.1:12220"`
|Yes
|Specifies that the server should bind to the given IP address and TCP port.  In
general, servers can bind to more than one IP address and port, but this is not
(yet?) supported.

|`log.mode`
|`"file"`
|Yes
|Controls where server logging will go.  Valid modes are `"stderr-terminal"` and
`"file".  If the mode is `"stderr-terminal"`, human-readable output, with colors
and other terminal formatting if possible, will be sent to stderr.  If the mode
is `"file"`, Bunyan-format output will be sent to the filesystem path given by
`log.path`.  See also `log.if_exists`, which controls the behavior if the
destination path already exists.

|`log.level`
|`"info"`
|Yes
|Specifies what severity of log messages should be included in the log.  Valid
values include `"trace"`, `"debug"`, `"info"`, `"warn"`, `"error"`, and
`"critical"`, which are increasing order of severity.  Log messages at the
specified level and more severe levels will be included in the log.

|`log.path`
|`"logs/server.log"`
|Only if `log.mode = "file"`
|If `log.mode` is `"file"`, this property determines the path to the log file.
See also `log.if_exists`.

|`log.if_exists`
|`"append"`
|Only if `log.mode = "file"`
|If `log.mode` is `"file"`, this property specifies what to do if the
destination log file already exists.  Valid values include `"append"` (which
appends to the existing file), `"truncate"` (which truncates the existing file
and then uses it as though it had just been created), and `"fail"` (which causes
the server to exit immediately with an error).

|===


== TODO

* Clean up the dropshot::HttpServer interface.
** review Cargo dependencies between dropshot and API
** Retest that log files are created, kept, and removed when expected (both test
   suites)
** self-review changes -- and commits (shouldn't go in as many commits to master)
* Repo cleanup
** incorporate openapi directly into this subcrate
** rename "lib" to something else (e.g., "local_deps")
** Dropshot itself should be documented
* Flesh out more endpoints and simulator
* Write out road map
** regions, AZs, etc. need to be added per RFD 24
* General work:
** OpenAPI support: Rust macros, tooling to generate spec, client librar(ies),
   CLI
** Debugging / monitoring
*** Prometheus?
*** OpenTracing?  OpenTelemetry?
*** Dynamic tracing?
*** Core files?
*** Internal APIs for:
**** showing connected clients, recent requests, ...?
** Rack-Internal API?
*** Alerts?
*** Faults?  Support bundles?
** Audit logging
** Authentication
** Authorization
** Data storage
*** What's the scope of these servers?
*** CAP choices
*** Active/Active, Active/Passive, Consensus?
** TLS
** Versioning (header? path? translators for older versions?)
** Pagination? (Opaque token?  What does Stripe do?)
** Hardening (see RFD 10)
*** throttling / load shedding
** Automated testing
*** Basic functionality
*** Performance testing
*** Stress testing
*** Fault testing / under load
*** Fuzz testing
** Security review
